import java.util.*;

public class Main {

    /*
     * ============================================================
     * TERMINOLOGY & CORE CONCEPTS
     * ============================================================
     * - People are nodes (0..n-1).
     * - Meetings are edges, valid only at their timestamp.
     * - DSU (Disjoint Set Union):
     *      - Groups nodes into connected components
     *      - Root = representative (unique ID of group)
     * - Carrier Group:
     *      - A DSU group that already has the secret.
     *      - If root of group is marked as carrier,
     *        all members in that group learn secret instantly.
     */

    // ============================================================
    // DSU CLASS
    // ============================================================
    static class DSU {
        int[] parent, rank;

        DSU(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) parent[i] = i;
        }

        // FIND with path compression
        int find(int x) {
            if (parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }

        // UNION with union by rank
        void union(int x, int y) {
            int px = find(x), py = find(y);
            if (px == py) return;

            if (rank[px] < rank[py]) {
                parent[px] = py;
            } else if (rank[px] > rank[py]) {
                parent[py] = px;
            } else {
                parent[py] = px;
                rank[px]++;
            }
        }
    }

    // ============================================================
    // SOLUTION
    // ============================================================
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt(); // number of people
        int m = sc.nextInt(); // number of meetings

        int[][] meetings = new int[m][3];
        for (int i = 0; i < m; i++) {
            meetings[i][0] = sc.nextInt();
            meetings[i][1] = sc.nextInt();
            meetings[i][2] = sc.nextInt();
        }

        int firstPerson = sc.nextInt();

        // Sort meetings chronologically
        Arrays.sort(meetings, Comparator.comparingInt(a -> a[2]));

        // People who know the secret
        Set<Integer> know = new HashSet<>();
        know.add(0);
        know.add(firstPerson);

        int i = 0;
        while (i < m) {
            int time = meetings[i][2];   // current timestamp
            List<int[]> group = new ArrayList<>();

            // collect all meetings happening at the same time
            while (i < m && meetings[i][2] == time) {
                group.add(meetings[i]);
                i++;
            }

            // Build DSU for this time slot
            DSU dsu = new DSU(n);
            Set<Integer> involved = new HashSet<>();

            for (int[] meet : group) {
                dsu.union(meet[0], meet[1]);
                involved.add(meet[0]);
                involved.add(meet[1]);
            }

            // Step: Identify carrier groups
            Set<Integer> carriers = new HashSet<>();
            for (int p : involved) {
                if (know.contains(p)) {
                    carriers.add(dsu.find(p));
                }
            }

            // Spread secret inside carrier groups
            for (int p : involved) {
                if (carriers.contains(dsu.find(p))) {
                    know.add(p);
                }
            }
        }

        // Final result
        List<Integer> result = new ArrayList<>(know);
        Collections.sort(result);
        System.out.println(result);
    }
}

chatgpt chat link:https://chatgpt.com/s/t_68bd570abab08191aeb89539e8b7c171
youtune link:https://youtu.be/zOeI9i8KUPw?feature=shared
